---
title: "UGR Tabellen - Beschreibung der Theorie und der Implementierung in R"
author: "William Truong"
date: "05.11.2021"
output: 
  html_document:
    number_sections: yes
    toc: yes
    toc_collapsed: yes
    toc_depth: 4
    toc_float: yes
editor_options:
  chunk_output_type: inline
bibliography: references.bib  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(ggplot2)
library(pracma)
library(openxlsx)
#library(knitr)
library(kableExtra)
```

# Einleitung

Das UGR-Verfahren (Uniefied Glare Rating) wird zur Bewertung der Direktblendung der künstlichen Beleuchtung in Innenräumen verwendet. In den folgenden Abschnitten wird auf den Aufbau der UGR-Formel und dessen Hintergründe kurz eingegangen, um anschließend die verschiedenen Schritte zur Berechnung dieser Größe zu beschreiben.

[@dehoff2003;@reiter2018]

## UGR

$$ R_{UG} = UGR = 8 \cdot \log_{10} \left( \frac{1}{4 L_b} \cdot
 \sum \frac{L_s^2 \cdot \Omega}{p^2} \right)$$

Dabei ist:

- $UGR$: Unified Glare Rating, Blendungszahl der Beleuchtungsanlage
- $L_b$: Hintergrundleuchtdichte in cd/m²
- $L_s$: Mittlere Leuchtdichte der einzelnen Leuchte in cd/m² in Beobachterrichtung 
- $\Omega$: Raumwinkel in sr unter dem die einzelne Leuchte gesehen wird
- $p$: Positionsindex der einzelnen Leuchte nach Guth, um den Einfluss der Leuchtenposition relativ zum Beobachter bei der Blendbewertung zu gewichten.

# Beispiele zur Berechnung der UGR Tabelle

In diesem Abschnitt werden die vordefinierten Lichtverteilungskurven (LVK) aus den CIE Normen [@cie1995;@cie2010] im EULUMDAT-Format (*.ldt) eingelesen. Die in der LDT-Datei eingetragenen Leuchtendaten werden verwendete, um die entsprechenden UGR-Tabellen zu erzeugen.

## Manuelle Eingaben

```{r}
dir_path <- "H:/Projekte/RStudio/LVK"

files_path <- list.files(
	path = dir_path,
	pattern = c(".ldt$"),
	full.names = TRUE,
	recursive = TRUE,
	ignore.case = TRUE
)
```


## CIE 190:2010 Tabelle 7

```{r}
file <- files_path[3]

# Einlesen der txt-Zeilen
LDT <- readLines(file)
```

### Einlesen der LDT-Datei

#### Header-Daten
```{r}
# Art der Symmetrie Isym
Isym <- LDT[3]
# Anzahl Mc der C-Ebenen zwischen 0° und 360°
Mc <- LDT[4] %>% as.numeric()
# Winkelintervall Dc zwischen den C-Ebenen
#   (Dc = 0 für nicht-äquidistante C-Ebenen)
Dc <- LDT[5] %>% as.numeric()
# Anzahl Ng der Lichtstärkewerte in jeder C-Ebene
Ng <- LDT[6] %>% as.numeric()
# Winkelintervall Dg <- zwischen den Lichtstärke werten einer C-Ebene
#   (Dg = 0 für nicht-äquidistante Lichtstärkewerte in einer C-Ebene)
Dg <- LDT[7] %>% as.numeric()
# Abmessungen der Leuchte l x b x h in m
l <- LDT[13] %>% as.numeric() / 1000
b <- LDT[14] %>% as.numeric() / 1000
h <- LDT[15] %>% as.numeric() / 1000
# Abmessungen der leuchtende Fläche in m
l_lum <- LDT[16] %>% as.numeric() / 1000
b_lum <- LDT[17] %>% as.numeric() / 1000
h_lum <- LDT[18:21] %>% as.numeric() / 1000
# Anzahl der Lampen
N_lamp <- LDT[26] %>% as.numeric()
# Lichtstrom aller Lampen
light_flux <- LDT[29] %>% as.numeric()
```

### Einlesen von CIE 190:2010 Tabellen

#### Transfer factor values


#### Winkel- und Lichtstärke-Daten
```{r}
# Offsets
offset1 <- 32 + (N_lamp - 1) * 6
offset2 <- offset1 + 10
offset3 <- offset2 + Mc
offset4 <- offset3 + Ng

# Lampendaten
lamp_data <- LDT[27:offset1]
# Direct Ratios für definierte Raum-Indexe
direct_ratios <- LDT[(offset1 + 1):offset2]
# C-Winkel
C_angle <- LDT[(offset2 + 1):offset3] %>% as.numeric()
# G-Winkel (gamma)
G_angle <- LDT[(offset3 + 1):offset4] %>% as.numeric()
if (Isym == "3") {G_angle <- G_angle + 90}

data <- LDT[-(1:offset4)]

switch(Isym,
	`0` = C_end_value <- Mc,
	`1` = C_end_value <- 1,
	`2` = C_end_value <- Mc / 2 + 1,
	`3` = C_end_value <- Mc / 2 + 1,
	`4` = C_end_value <- Mc / 4 + 1
)

df_I <- data.frame(G = numeric(), C = numeric(), I = numeric())
data_sub <- data
for (angle in C_angle[1:C_end_value]) {
	G <- G_angle
	C <- if_else(Isym != "3", angle, angle + 90)
	I <- data_sub[1:Ng] %>% as.numeric()
	data_sub <- data_sub[-(1:Ng)]
	df_I <- data.frame(G, C, I) %>%
		bind_rows(df_I, .)
}
```


### Vorverarbeitung der LDT-Daten

#### Korrekturberechnung des Lichtstärke der C-Ebenen bei gamma = 0

Später einbauen

```{r}

```

#### Berechnung der Partiallichtströme und Betriebswirkungsgrade

```{r}
# Berechne die Verschiebung der gamma-Winkel für Partiallichtströme
G_1 <- G_angle - Dg / 2
G_2 <- G_angle + Dg / 2
G_zonal_flux <- G_2
G_1 <- if_else(G_1 < 0  ,   0, G_1)
G_2 <- if_else(G_2 > 180, 180, G_2)
# Berechnung des Raumwinkels Omega aller Teillichtströme
Omega <- 2 * pi * ( cos(G_1 * pi / 180) - cos(G_2 * pi / 180) )
# Aufhebung der normierten Lichtstärkewerte
df_I_wide <- df_I %>%
	mutate( I_abs = I * (light_flux / 1000) ) %>%
	select(-I) %>%
	pivot_wider(names_from = C, values_from = I_abs) %>%
	mutate(
		I_avg = rowMeans(across(-G)),
		zonal_flux = I_avg * Omega
		)
zonal_flux_cumsum <- cumsum(df_I_wide$zonal_flux)
# lineare Interpolation
FCL <- interp1( G_zonal_flux, zonal_flux_cumsum, c(41.4, 60, 75, 90) )
R_LO  <- tail(zonal_flux_cumsum, 1) / light_flux   # light output ratio
F_S   <- R_LO * 1000 / tail(zonal_flux_cumsum, 1)  # scale factor
R_DLO <- FCL[4] * F_S / light_flux # downward light output ratio
R_ULO <- R_LO - R_DLO				       # upward light output ratio

```
[@cie2010] Seite 19-20:

- FCL1: `r round(FCL[1], 2)` $\equiv$ 338.52 $= \Phi_{zL1}$
- FCL2: `r round(FCL[2], 2)` $\equiv$ 534.39 $= \Phi_{zL2}$
- FCL3: `r round(FCL[3], 2)` $\equiv$ 621.25 $= \Phi_{zL3}$
- FCL4: `r round(FCL[4], 2)` $\equiv$ 650.12 $= \Phi_{zL4}$
- R_LO: `r round(R_LO, 3)` $\equiv$ 0.65 $= R_{LO}$
- F_S: `r round(F_S, 3)` $\equiv$ 0.996 $= F_{S}$
- R_DLO: `r round(R_DLO, 3)` $\equiv$ 0.65 $= R_{DLO}$
- R_ULO: `r round(R_ULO, 3)` $\equiv$ 0 $= R_{ULO}$


<!-- ```{r} -->
<!-- # Berechnung des Flux-Codes (N - Faktoren) aus CIE 52-82 -->
<!-- # zur Berechnung der Hintergrundleuchtdichte -->
<!-- N1 <- FCL[1] / FCL[4] -->
<!-- N2 <- FCL[2] / FCL[4] -->
<!-- N3 <- FCL[3] / FCL[4] -->
<!-- N4 <- R_DLO / R_LO -->
<!-- N5 <- R_LO -->
<!-- ``` -->

#### Definition der Raumdimensionen

```{r}
SHR <- 1 / 1       # Space to Height Ratio
H <- 2             # Montagehöhe der Leuchte bzgl. Beobachterposition
S <- SHR * H       # Abstand zwischen Leuchten
S2 <- S / 2
```

Raumdaten und dazugehörige Transferfaktorenwerte ("transfer factor values") aus [@cie2010] Tabelle 5.

```{r}
room_param <- readWorkbook(
	"CIE-190-2010_tables.xlsx",
	sheet = "Table 5_long",
	startRow = 1
	) %>%
	mutate(
		`Reflectance_C/W/R` = factor(
			`Reflectance_C/W/R`, 
			levels = unique(`Reflectance_C/W/R`), 
			ordered = TRUE
			),
		X_Dim = factor(X_Dim, levels = unique(X_Dim), ordered = TRUE),
		Y_Dim = factor(Y_Dim, levels = unique(Y_Dim), ordered = TRUE),
		X_abs = sub("H", "", X_Dim) %>% as.numeric() * H, # in m
		Y_abs = sub("H", "", Y_Dim) %>% as.numeric() * H  # in m
	)

kable(room_param) %>% kable_classic()
```

#### Berechnung der Leuchtenpositionen

Nur die in der CIE 190:2010 betrachtetenden Raum-Dimensionen werden in den folgenden Tabellen angezeigt, um die einzelnen Schritte der Berechnung übersichtlich kontrollieren zu können. Die komplette UGR Tabelle wird am Ende ausgegeben.

```{r}
luminaire <- room_param %>% 
	group_by(`Reflectance_C/W/R`, X_Dim, Y_Dim) %>% 
	expand(
		seq(-(X_abs / H) + S2, (X_abs / H) - S2, S),
		seq(S2, Y_abs, S),
		) %>% 
	rename("X" = 4, "Y" = 5) %>% 
	left_join(room_param, by = c("Reflectance_C/W/R", "X_Dim", "Y_Dim")) %>% 
	ungroup()

luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```

### Berechnung der Direktblendung

#### Berechnung der Distanz / Sichtwinkel zwischen Leuchte und Beobachter und der sichtbaren leuchtenden Fläche

Leuchtende Fläche wurde vorgegeben und wird nicht aus der LDT-Datei entnommen.

```{r}
A_B <- 0.316 # area of luminous base in m²
A_S <- 0     # area of luminous side in m²
A_E <- 0     # area of luminous end  in m²

luminaire <- luminaire %>%
	mutate(
		R = sqrt(X^2 + Y^2 + H^2),
		G = acos(H / R) / pi * 180,
		C_crosswise = atan(X / Y) / pi * 180,
		C_crosswise = if_else(X < 0, C_crosswise + 360, C_crosswise),
		C_endwise = 90 + atan(X / Y) / pi * 180,
		Ap_endwise  = A_B * H / R + A_S * X / R + A_E * Y / R,
		Ap_crosswise = A_B * H / R + A_S * X / R + A_E * Y / R
		)
luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```




<!-- #### Berechnung der sichtbaren Leuchtenfläche -->

<!-- Wird hier nicht implementiert sondern erst beim nächsten Beispiel -->

<!-- ```{r} -->
<!-- # # Berechne Mittelwert der Höhe der leuchtenden Fläche -->
<!-- # luminaire_height <- mean(h_lum) -->
<!-- # Ist die leuchtende Fläche rechteckig? -->
<!-- A_B <- 0.316 # area of luminous base in m² -->
<!-- A_S <- 0     # area of luminous side in m² -->
<!-- A_E <- 0     # area of luminous end  in m² -->

<!-- # A_B <- 0.1452 # area of luminous base in m² -->
<!-- # A_S <- 0     # area of luminous side in m² -->
<!-- # A_E <- 0     # area of luminous end  in m² -->

<!-- # Nach CIE 2010 linear luminaires -->
<!-- luminaire <- luminaire %>% -->
<!-- 	mutate( -->
<!-- 		A_end  = A_B * H / R + A_S * X / R + A_E * Y / R, -->
<!-- 		A_cross = A_B * H / R + A_S * X / R + A_E * Y / R -->
<!-- 		) -->

<!-- ``` -->

#### Berechnung des Positionsindexes

```{r}
t4.1 <- read.csv("CIE-117-1995_table4.1.csv", skip = 1, check.names = F) %>%
	filter(!is.na(`T/R`))
X_Y_x <- t4.1$`T/R`
H_Y_x <- select(t4.1, -`T/R`) %>% colnames() %>% as.numeric()
p_x <- select(t4.1, -`T/R`) %>% data.matrix() %>% t()

luminaire <- luminaire %>%
	mutate(
		X_Y = abs(X / Y),
		H_Y = abs(H / Y),
		p = interp2(X_Y_x, H_Y_x, p_x, X_Y, H_Y)
	)
luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```

#### Berechnung der Lichtstärke der Leuchten zum Beobachter

```{r}
G_x <- unique(df_I$G)
# add additional C360 for interpolating. Same values as C0
C_x <- unique(df_I$C) %>% c(360)
I_x <- select(df_I_wide, -c(G, I_avg, zonal_flux)) %>%
	mutate(`360` = `0`) %>%
	t()

luminaire <- luminaire %>% 
	mutate(
		ICG_crosswise = interp2(G_x, C_x, I_x, G, C_crosswise),
		ICG_endwise = interp2(G_x, C_x, I_x, G, C_endwise)
	) %>% 
	pivot_longer(
		cols = ends_with("wise"),
		names_to = c(".value", "View"),
		names_pattern = "(.*)_(.*)"
		) %>% 
	rename(A_p = Ap, I_CG = ICG)

luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```

#### Zur Kontrolle des K-Faktors in CIE 2010

```{r}
luminaire <- luminaire %>%
	mutate(K = pi / (4 * R^2 * p^2))

luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```

### Berechnungen für die Hintergrundleuchtdichte nach CIE 2010

#### Berechnung der Wandflächen und Anzahl der Leuchten

```{r}
luminaire <- luminaire %>%
	mutate(
		A_wall = 2 * X_abs * H + 2 * Y_abs * H,
		N = X_abs / S * Y_abs / S,
		B = light_flux * N / A_wall
		)
luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```
#### Geometrischer Faktor (geometric factor) for luminaires in standard array
```{r}
t4 <- readWorkbook("CIE-190-2010_tables.xlsx", sheet = "Table 4", startRow = 1)
luminaire <- left_join(luminaire, t4, by = c("X_Dim", "Y_Dim")) %>% 
	mutate(
		zonal_flux = FCL[1] * F_GL1 + FCL[2] * F_GL2 + FCL[3] * F_GL3 + 
			FCL[4] * F_GL4,
		F_DF = zonal_flux / 1000,
		F_DW = R_DLO - F_DF,
		F_DC = R_ULO,
		F_UWID = F_DF * `F_T,FW` + F_DW * `F_T,WW-1` + F_DC * `F_T,CW`,
		B = 1000 * N / A_wall,
		E_WID = F_UWID * B
	)
luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```

### UGR 

#### Berechnung

```{r}
UGR_sum <- luminaire %>% 
	na.omit() %>% 
	# Calculating the sum-part before taking the sum
	mutate(SUM = I_CG^2 /( A_p * R^2 * p^2)) %>% 
	group_by(`Reflectance_C/W/R`, X_Dim, Y_Dim, View) %>% 
	summarise(across(SUM, sum )) %>% 
	ungroup()

UGR <- luminaire %>% 
	select(`Reflectance_C/W/R`, X_Dim, Y_Dim, E_WID) %>% 
	distinct() %>% 
	right_join(UGR_sum, by = c("Reflectance_C/W/R", "X_Dim", "Y_Dim")) %>% 
	mutate(UGR = 8 * log10(SUM / 4) - 8 * log10 (E_WID / pi)) %>% 
	mutate(UGR = round(UGR, 1)) %>% 
	arrange(View) %>% 
	select(-c(E_WID, SUM))

UGR %>% 
	kable() %>% 
	kable_classic()

```
#### Erstellung der Tabelle 

```{r}
reflectance_names <- unique(UGR$`Reflectance_C/W/R`) %>% as.character()

UGR_table <- UGR %>% 
	pivot_wider(
		names_from = c(View, `Reflectance_C/W/R`), 
		names_glue = "{.value}_{View}_{`Reflectance_C/W/R`}",
		values_from = UGR
		)

kbl(
	UGR_table, 
	align = c("r"),
	col.names = c("X", "Y", reflectance_names, reflectance_names)
	) %>% 
	kable_paper() %>% 
	add_header_above(c(
		"Room Dimensions" = 2,
		"Reflectances (Ceiling/Wall/Reference plane)" = 5,
		"Reflectances (Ceiling/Wall/Reference plane)" = 5
		)) %>%
	add_header_above(c(
		" " = 2,
		"Viewed crosswise" = 5,
		"Viewed endwise" = 5
		)) %>%
	row_spec(c(6, 12, 16), extra_css = "border-bottom: 1px solid")
```

## CIE 117:1995 Tabelle D1

```{r}
file <- files_path[1]

# Einlesen der txt-Zeilen
LDT <- readLines(file)
```

### Einlesen der LDT-Datei

#### Header-Daten
```{r}
# Art der Symmetrie Isym
Isym <- LDT[3]
# Anzahl Mc der C-Ebenen zwischen 0° und 360°
Mc <- LDT[4] %>% as.numeric()
# Winkelintervall Dc zwischen den C-Ebenen
#   (Dc = 0 für nicht-äquidistante C-Ebenen)
Dc <- LDT[5] %>% as.numeric()
# Anzahl Ng der Lichtstärkewerte in jeder C-Ebene
Ng <- LDT[6] %>% as.numeric()
# Winkelintervall Dg <- zwischen den Lichtstärke werten einer C-Ebene
#   (Dg = 0 für nicht-äquidistante Lichtstärkewerte in einer C-Ebene)
Dg <- LDT[7] %>% as.numeric()
# Abmessungen der Leuchte l x b x h in m
l <- LDT[13] %>% as.numeric() / 1000
b <- LDT[14] %>% as.numeric() / 1000
h <- LDT[15] %>% as.numeric() / 1000
# Abmessungen der leuchtende Fläche in m
l_lum <- LDT[16] %>% as.numeric() / 1000
b_lum <- LDT[17] %>% as.numeric() / 1000
h_lum <- LDT[18:21] %>% as.numeric() / 1000
# Anzahl der Lampen
N_lamp <- LDT[26] %>% as.numeric()
# Lichtstrom aller Lampen
light_flux <- LDT[29] %>% as.numeric()
```

### Einlesen von CIE 190:2010 Tabellen

#### Transfer factor values


#### Winkel- und Lichtstärke-Daten
```{r}
# Offsets
offset1 <- 32 + (N_lamp - 1) * 6
offset2 <- offset1 + 10
offset3 <- offset2 + Mc
offset4 <- offset3 + Ng

# Lampendaten
lamp_data <- LDT[27:offset1]
# Direct Ratios für definierte Raum-Indexe
direct_ratios <- LDT[(offset1 + 1):offset2]
# C-Winkel
C_angle <- LDT[(offset2 + 1):offset3] %>% as.numeric()
# G-Winkel (gamma)
G_angle <- LDT[(offset3 + 1):offset4] %>% as.numeric()
if (Isym == "3") {G_angle <- G_angle + 90}

data <- LDT[-(1:offset4)]

switch(Isym,
	`0` = C_end_value <- Mc,
	`1` = C_end_value <- 1,
	`2` = C_end_value <- Mc / 2 + 1,
	`3` = C_end_value <- Mc / 2 + 1,
	`4` = C_end_value <- Mc / 4 + 1
)

df_I <- data.frame(G = numeric(), C = numeric(), I = numeric())
data_sub <- data
for (angle in C_angle[1:C_end_value]) {
	G <- G_angle
	C <- if_else(Isym != "3", angle, angle + 90)
	I <- data_sub[1:Ng] %>% as.numeric()
	data_sub <- data_sub[-(1:Ng)]
	df_I <- data.frame(G, C, I) %>%
		bind_rows(df_I, .)
}
```


### Vorverarbeitung der LDT-Daten

#### Korrekturberechnung des Lichtstärke der C-Ebenen bei gamma = 0

Später einbauen

```{r}

```

#### Berechnung der Partiallichtströme und Betriebswirkungsgrade

```{r}
# Berechne die Verschiebung der gamma-Winkel für Partiallichtströme
G_1 <- G_angle - Dg / 2
G_2 <- G_angle + Dg / 2
G_zonal_flux <- G_2
G_1 <- if_else(G_1 < 0  ,   0, G_1)
G_2 <- if_else(G_2 > 180, 180, G_2)
# Berechnung des Raumwinkels Omega aller Teillichtströme
Omega <- 2 * pi * ( cos(G_1 * pi / 180) - cos(G_2 * pi / 180) )
# Aufhebung der normierten Lichtstärkewerte
df_I_wide <- df_I %>%
	mutate( I_abs = I * (light_flux / 1000) ) %>%
	select(-I) %>%
	pivot_wider(names_from = C, values_from = I_abs) %>%
	mutate(
		I_avg = rowMeans(across(-G)),
		zonal_flux = I_avg * Omega
		)
zonal_flux_cumsum <- cumsum(df_I_wide$zonal_flux)
# lineare Interpolation
FCL <- interp1( G_zonal_flux, zonal_flux_cumsum, c(41.4, 60, 75, 90) )
R_LO  <- tail(zonal_flux_cumsum, 1) / light_flux   # light output ratio
F_S   <- R_LO * 1000 / tail(zonal_flux_cumsum, 1)  # scale factor
R_DLO <- FCL[4] * F_S / light_flux # downward light output ratio
R_ULO <- R_LO - R_DLO				       # upward light output ratio

```


#### Definition der Raumdimensionen

```{r}
SHR <- 0.25 / 1       # Space to Height Ratio
H <- 2             # Montagehöhe der Leuchte bzgl. Beobachterposition
S <- SHR * H       # Abstand zwischen Leuchten
S2 <- S / 2
```

Raumdaten und dazugehörige Transferfaktorenwerte ("transfer factor values") aus [@cie2010] Tabelle 5.

```{r}
room_param <- readWorkbook(
	"CIE-190-2010_tables.xlsx",
	sheet = "Table 5_long",
	startRow = 1
	) %>%
	mutate(
		`Reflectance_C/W/R` = factor(
			`Reflectance_C/W/R`, 
			levels = unique(`Reflectance_C/W/R`), 
			ordered = TRUE
			),
		X_Dim = factor(X_Dim, levels = unique(X_Dim), ordered = TRUE),
		Y_Dim = factor(Y_Dim, levels = unique(Y_Dim), ordered = TRUE),
		X_abs = sub("H", "", X_Dim) %>% as.numeric() * H, # in m
		Y_abs = sub("H", "", Y_Dim) %>% as.numeric() * H  # in m
	)

kable(room_param) %>% kable_classic()
```

#### Berechnung der Leuchtenpositionen

Nur die in der CIE 190:2010 betrachtetenden Raum-Dimensionen werden in den folgenden Tabellen angezeigt, um die einzelnen Schritte der Berechnung übersichtlich kontrollieren zu können. Die komplette UGR Tabelle wird am Ende ausgegeben.

```{r}
luminaire <- room_param %>% 
	group_by(`Reflectance_C/W/R`, X_Dim, Y_Dim) %>% 
	expand(
		seq(-(X_abs / H) + S2, (X_abs / H) - S2, S),
		seq(S2, Y_abs, S),
		) %>% 
	rename("X" = 4, "Y" = 5) %>% 
	left_join(room_param, by = c("Reflectance_C/W/R", "X_Dim", "Y_Dim")) %>% 
	ungroup()

luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```

### Berechnung der Direktblendung

#### Berechnung der Distanz / Sichtwinkel zwischen Leuchte und Beobachter und der sichtbaren leuchtenden Fläche

Unbedingt hier eine Grafik mit der Definition der C-Ebenen einer Leuchte darstellen, um die C-Ebenen Winkeln zu verstehen. 

```{r}
test <- luminaire %>%
	mutate(
		R = sqrt(X^2 + Y^2 + H^2),
		G = acos(H / R) / pi * 180,
		C_crosswise = - atan(X / Y) / pi * 180,
		C_crosswise = if_else(X > 0, C_crosswise + 360, C_crosswise),
		# Drehung der Leuchten um 90°
		C_endwise = if_else(X > 0, C_crosswise - 270, C_crosswise + 90)
		)
```



Berechnung der sichtbaren leuchtende Fläche $A_p$ nach CIE 117 1995 Abbildung C3



```{r}
# Ist die leuchtende Fläche rechteckig?
if ( LDT[16] > 0 & LDT[17] > 0 ) {
	# Ist die leuchtende Fläche ein Quader?
	if ( mean(as.numeric(LDT[18:21])) > 0 ) {
		Ap_crosswise <- 
	}
} 

```


```{r}
A_B <- 0.1425 # area of luminous base in m²
A_S <- 0      # area of luminous side in m²
A_E <- 0      # area of luminous end  in m²



luminaire <- luminaire %>%
	mutate(
		R = sqrt(X^2 + Y^2 + H^2),
		G = acos(H / R) / pi * 180,
		C_crosswise = atan(X / Y) / pi * 180,
		C_crosswise = if_else(X < 0, C_crosswise + 360, C_crosswise),
		C_endwise = 90 + atan(X / Y) / pi * 180,
		Ap_endwise  = A_B * H / R + A_S * X / R + A_E * Y / R,
		Ap_crosswise = A_B * H / R + A_S * X / R + A_E * Y / R
		)
luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```

#### Berechnung des Positionsindexes

```{r}
t4.1 <- read.csv("CIE-117-1995_table4.1.csv", skip = 1, check.names = F) %>%
	filter(!is.na(`T/R`))
X_Y_x <- t4.1$`T/R`
H_Y_x <- select(t4.1, -`T/R`) %>% colnames() %>% as.numeric()
p_x <- select(t4.1, -`T/R`) %>% data.matrix() %>% t()

luminaire <- luminaire %>%
	mutate(
		X_Y = abs(X / Y),
		H_Y = abs(H / Y),
		p = interp2(X_Y_x, H_Y_x, p_x, X_Y, H_Y)
	)
luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```

#### Berechnung der Lichtstärke der Leuchten zum Beobachter

```{r}
G_x <- unique(df_I$G)
# add additional C360 for interpolating. Same values as C0
C_x <- unique(df_I$C) %>% c(360)
I_x <- select(df_I_wide, -c(G, I_avg, zonal_flux)) %>%
	mutate(`360` = `0`) %>%
	t()

luminaire <- luminaire %>% 
	mutate(
		ICG_crosswise = interp2(G_x, C_x, I_x, G, C_crosswise),
		ICG_endwise = interp2(G_x, C_x, I_x, G, C_endwise)
	) %>% 
	pivot_longer(
		cols = ends_with("wise"),
		names_to = c(".value", "View"),
		names_pattern = "(.*)_(.*)"
		) %>% 
	rename(A_p = Ap, I_CG = ICG)

luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```

### Berechnungen für die Hintergrundleuchtdichte nach CIE 2010

#### Berechnung der Wandflächen und Anzahl der Leuchten

```{r}
luminaire <- luminaire %>%
	mutate(
		A_wall = 2 * X_abs * H + 2 * Y_abs * H,
		N = X_abs / S * Y_abs / S,
		B = light_flux * N / A_wall
		)
luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```

#### Geometrischer Faktor (geometric factor) for luminaires in standard array
```{r}
t4 <- readWorkbook("CIE-190-2010_tables.xlsx", sheet = "Table 4", startRow = 1)
luminaire <- left_join(luminaire, t4, by = c("X_Dim", "Y_Dim")) %>% 
	mutate(
		zonal_flux = FCL[1] * F_GL1 + FCL[2] * F_GL2 + FCL[3] * F_GL3 + 
			FCL[4] * F_GL4,
		F_DF = zonal_flux / 1000,
		F_DW = R_DLO - F_DF,
		F_DC = R_ULO,
		F_UWID = F_DF * `F_T,FW` + F_DW * `F_T,WW-1` + F_DC * `F_T,CW`,
		B = 1000 * N / A_wall,
		E_WID = F_UWID * B
	)
luminaire %>% 
	filter(`Reflectance_C/W/R` == "70/50/20" & X_Dim == "2H" & Y_Dim == "4H") %>% 
	kable() %>% 
	kable_classic()
```

### UGR 

#### Berechnung

```{r}
UGR_sum <- luminaire %>% 
	na.omit() %>% 
	# Calculating the sum-part before taking the sum
	mutate(SUM = I_CG^2 /( A_p * R^2 * p^2)) %>% 
	group_by(`Reflectance_C/W/R`, X_Dim, Y_Dim, View) %>% 
	summarise(across(SUM, sum )) %>% 
	ungroup()

UGR <- luminaire %>% 
	select(`Reflectance_C/W/R`, X_Dim, Y_Dim, E_WID) %>% 
	distinct() %>% 
	right_join(UGR_sum, by = c("Reflectance_C/W/R", "X_Dim", "Y_Dim")) %>% 
	mutate(UGR = 8 * log10(SUM / 4) - 8 * log10 (E_WID / pi)) %>% 
	mutate(UGR = round(UGR, 1)) %>% 
	arrange(View) %>% 
	select(-c(E_WID, SUM))

UGR %>% 
	kable() %>% 
	kable_classic()

```

#### Erstellung der Tabelle 

```{r}
reflectance_names <- unique(UGR$`Reflectance_C/W/R`) %>% as.character()

UGR_table <- UGR %>% 
	pivot_wider(
		names_from = c(View, `Reflectance_C/W/R`), 
		names_glue = "{.value}_{View}_{`Reflectance_C/W/R`}",
		values_from = UGR
		)

kbl(
	UGR_table, 
	align = c("r"),
	col.names = c("X", "Y", reflectance_names, reflectance_names)
	) %>% 
	kable_paper() %>% 
	add_header_above(c(
		"Room Dimensions" = 2,
		"Reflectances (Ceiling/Wall/Reference plane)" = 5,
		"Reflectances (Ceiling/Wall/Reference plane)" = 5
		)) %>%
	add_header_above(c(
		" " = 2,
		"Viewed crosswise" = 5,
		"Viewed endwise" = 5
		)) %>%
	row_spec(c(6, 12, 16), extra_css = "border-bottom: 1px solid")
```

